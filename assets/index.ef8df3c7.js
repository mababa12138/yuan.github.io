import{m as t,C as r,d as e,c as o,a as n,F as a,r as s,t as l,w as c,p as i,b as m,o as y,e as b,f as p}from"./vendor.dce987d7.js";!function(t=".",r="__import__"){try{self[r]=new Function("u","return import(u)")}catch(e){const o=new URL(t,location),n=t=>{URL.revokeObjectURL(t.src),t.remove()};self[r]=t=>new Promise(((e,a)=>{const s=new URL(t,o);if(self[r].moduleMap[s])return e(self[r].moduleMap[s]);const l=new Blob([`import * as m from '${s}';`,`${r}.moduleMap['${s}']=m;`],{type:"text/javascript"}),c=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(l),onerror(){a(new Error(`Failed to import: ${t}`)),n(c)},onload(){e(self[r].moduleMap[s]),n(c)}});document.head.appendChild(c)})),self[r].moduleMap={}}}("assets/");const S={jsCheat:"### 本文意在记录JS中的语法，可以理解为拳皇的出招表\r\n\t文章顺序参考JavaScript高级程序设计，不包含DOM、BOM等浏览器扩展的对象\r\n\t文章内会将有功能关联的方法/构造函数/对象等放在临近的位置\r\n\t后续考虑使用索引进行说明\r\n本文代码中会提供部分示例以说明其使用方法，如果有不理解的或更好的优化建议，请在下方评论，下面开始使用JS出招表：\r\n```js\r\nSymbol // 符号，表示唯一，Symbol('foo') != Symbol('foo')，typeof检测symbol类型为 'symbol' \r\nSymbol.for() // let a = Symbol.for('foo') let b = Symbol.for('foo')  =>  a === b\r\nSymbol.keyFor() // let a = Symbol.for('foo') Symbol.keyFor(a) === 'foo'\r\nSymbol.asyncIterator // 该方法返回对象默认的AsyncInterator,由for-await-of使用, 用来实现异步迭代器API的函数\r\nSymbol.hasInstance // 等同于instanceof,只是使用方式略有区别， f instance Foo => Foo[Symbol.instance](f)\r\nSymbol.isConcatSpreadable // 修改concat的行为,Symbol.isConcatSpreadable = false时, 会将concat传入的参数以原始对象的形式添加到数组末尾.\r\nSymbol.iterator // 该方法返回对象默认的迭代器,由for-of使用\r\nSymbol.match // 调用String.prototype.match()会调用Symbol.match为键的方法 [Symbol.match](target) { return target.includes('foo') }\r\nSymbol.replace // 使用方法同上,替换String.prototype.repalace()\r\nSymbol.search // 对应String.prototype.search() 使用方法同上\r\nSymbol.species // 一个函数值，该函数作为创建派生对象的构造函数\r\nSymbol.split // 通match，[Symbol.split](target)\r\nSymbol.toPrimitive // 一个方法，该方法将对象转换为相应的原始值，可以覆盖原始类型转换的表现，[Symbol.toPrimitive](hint) { if (hint === 'number') return hint + 1 }\r\nSymbol.toStringTag // 使用toSting获取对象标识时，会获取Symbol.toStringTag指定的实例标识符 class Bar { this[Symbol.toStringTag] = 'Bar' } let bar = new Bar() bar.toString() -> Bar\r\n\r\nObject.getOwnPropertyNames() // 只返回常规属性数组\r\nObject.getOwnPropertySymbols() // 只返回字符属性数组\r\nObject.getOwnPropertyDescriptors() // 会返回同时包含常规和符号属性描述符的对象\r\n\r\n// Object实例默认方法\r\n// 每个Object实例都有如下属性和方法\r\nconst obj = new Object()\r\nobj.constructor // 指向构造函数\r\nobj.hasOwnProperty(propertyName) // 用于判断当前对象实例上是否存在给定的属性\r\nobj.isPrototypeof(object) // 用于判断当前对象是否为另一个对象的原型\r\nobj.propertyIsEnumerable(propertyName) // 用于判断当前对象是否可以使用for-in语句枚举\r\nobj.toLocaleString() // 返回对象的字符串表示，该字符串反应对象所在本地化执行环境\r\nobj.toString() // 返回对象的字符串表示\r\nobj.valueOf() // 返回对象对应的字符串、数值、或布尔值表示\r\n\r\n// 操作符\r\n(3 ** 2) // 9 , 指数操作符，等同于Math.pow(3, 2)\r\nlet num = (1, 2, 3, 4, 5) // 逗号操作符，num的值为0，即返回表达式中最后一个值\r\n```\r\n以下是一些冷门方法或函数的用法\r\n```js\r\n// Symbol.asyncIterator\r\nclass Emitter {\r\n\tconstructor(max) {\r\n\t\tthis.max = max\r\n\t\tthis.asyncIdx = 0\r\n\t}\r\n\tasync *[Symbol.asyncIterator] () {\r\n\t\twhile(this.asyncIdx < this.max) {\r\n\t\t\tyield new Promise((resolve) => resolve(this.asyncIdx++))\r\n\t\t}\r\n\t}\r\n}\r\nasync function asyncCount() {\r\n\tlet emitter = new Emitter(5)\r\n\tfor await (const x of emitter) {\r\n\t\tconsole.log(x)\r\n\t}\r\n}\r\nasyncCount() // 0 1 2 3 4\r\n```\r\n"};t.setOptions({highlight:function(t){return r.highlight(t,{language:"javascript"}).value}});const u=Object.keys(S).reduce(((r,e)=>(r[e]=t(S[e],{sanitize:!0}).replace(/<pre>/g,"<pre class='hljs'>"),r)),{});var d=e({name:"HelloWorld",props:{msg:{type:String,required:!0}},data:()=>({curArticle:"",htmlStrings:Object.freeze(u)}),methods:{showMarkdown(t){console.log(t)}},computed:{article:t=>t.htmlStrings[t.curArticle]},created(){this.curArticle=Object.keys(this.htmlStrings)[0]}});const f=c();i("data-v-47eaca2c");const h={class:"catalogue"},g={class:"main"};m();const j=f(((t,r,e,c,i,m)=>(y(),o(a,null,[n("div",h,[(y(!0),o(a,null,s(Object.keys(t.htmlStrings),(r=>(y(),o("a",{key:r,class:{catalogue__item:!0,"catalogue__item--active":t.curArticle===r},onClick:e=>t.showMarkdown(r)},l(r),11,["onClick"])))),128))]),n("main",g,[n("h1",null,l(t.curArticle),1),n("article",{class:"context",innerHTML:t.article},null,8,["innerHTML"])])],64))));d.render=j,d.__scopeId="data-v-47eaca2c";var w=e({name:"App",components:{HelloWorld:d}});w.render=function(t,r,e,n,a,s){const l=b("HelloWorld");return y(),o(l,{msg:"Hello Vue 3 + TypeScript + Vite"})};p(w).mount("#app");
